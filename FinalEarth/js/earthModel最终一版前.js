function earth() {
    var lxcData = {
        "lst": [{
            "protoType": "tcp",
            "deviceType": 1,
            "warnningSource": "deivce",
            "srcCountry": "中国",
            "destCountry": "澳大利亚",
            "srcCity": "",
            "destCity": "堪培拉",
            "srcIP": "219.142.134.122",
            "destIP": "143.238.247.255",
            "srcPort": 400,
            "destPort": 451,
            "srcXY": ["116.455", "40.253"],
            "destXY": ["149.124", "-35.307"],
            "time": 1479092723000,
            "warnningTypeID": 3,
            "srcCountryID": "CN",
            "destCountryID": "AU",
            "oneDay_Count": 0,
            "servenDay_Count": 0,
            "month_Count": 5,
            "deviceID": "8667720296",
            "srcID": "FHT:4143406806480817898",
            "desID": "FHT:1058901190546244089",
            "threatID": "0"
        },
        {
            "protoType": "udp",
            "deviceType": 1,
            "warnningSource": "deivce",
            "srcCountry": "美国",
            "destCountry": "泰国",
            "srcCity": "",
            "destCity": "Bangkok",
            "srcIP": "209.11.82.100",
            "destIP": "125.26.56.255",
            "srcPort": 434,
            "destPort": 400,
            "srcXY": ["-77.0368", "38.907"],
            "destXY": ["100.502", "13.756"],
            "time": 1479092721000,
            "warnningTypeID": 17,
            "srcCountryID": "US",
            "destCountryID": "TH",
            "oneDay_Count": 8,
            "servenDay_Count": 60,
            "month_Count": 246,
            "deviceID": "0664676283",
            "srcID": "FHT:6959039227779431647",
            "desID": "FHT:5170933928520105515",
            "threatID": "0"
        },
        {
            "protoType": "udp",
            "deviceType": 3,
            "warnningSource": "deivce",
            "srcCountry": "澳大利亚",
            "destCountry": "中国",
            "srcCity": "",
            "destCity": "昆明",
            "srcIP": "143.238.247.255",
            "destIP": "61.166.150.138",
            "srcPort": 440,
            "destPort": 452,
            "srcXY": ["149.124", "-35.307"],
            "destXY": ["102.92", "25.466"],
            "time": 1479092719000,
            "warnningTypeID": 17,
            "srcCountryID": "AU",
            "destCountryID": "CN",
            "oneDay_Count": 1,
            "servenDay_Count": 13,
            "month_Count": 48,
            "deviceID": "8777735639",
            "srcID": "FHT:8354510674280022400",
            "desID": "FHT:2370002385192898922",
            "threatID": "0"
        },
        {
            "protoType": "udp",
            "deviceType": 2,
            "warnningSource": "deivce",
            "srcCountry": "中国",
            "destCountry": "中国",
            "srcCity": "",
            "destCity": "长沙",
            "srcIP": "219.142.134.122",
            "destIP": "175.0.255.255",
            "srcPort": 462,
            "destPort": 470,
            "srcXY": ["116.455", "40.253"],
            "destXY": ["113.082", "28.256"],
            "time": 1479092717000,
            "warnningTypeID": 3,
            "srcCountryID": "CN",
            "destCountryID": "CN",
            "oneDay_Count": 5,
            "servenDay_Count": 38,
            "month_Count": 165,
            "deviceID": "3928262928",
            "srcID": "FHT:1156659235830226280",
            "desID": "FHT:5642373134296253887",
            "threatID": "0"
        },
        {
            "protoType": "tcp",
            "deviceType": 5,
            "warnningSource": "deivce",
            "srcCountry": "中国",
            "destCountry": "泰国",
            "srcCity": "",
            "destCity": "Bangkok",
            "srcIP": "58.25.7.255",
            "destIP": "125.26.56.255",
            "srcPort": 435,
            "destPort": 493,
            "srcXY": ["121.465", "31.289"],
            "destXY": ["100.502", "13.756"],
            "time": 1479092715000,
            "warnningTypeID": 6,
            "srcCountryID": "CN",
            "destCountryID": "TH",
            "oneDay_Count": 4,
            "servenDay_Count": 31,
            "month_Count": 148,
            "deviceID": "7643957621",
            "srcID": "FHT:940003726009388121",
            "desID": "FHT:7877268033186651253",
            "threatID": "0"
        },
        {
            "protoType": "udp",
            "deviceType": 3,
            "warnningSource": "deivce",
            "srcCountry": "以色列",
            "destCountry": "中国",
            "srcCity": "",
            "destCity": "长沙",
            "srcIP": "89.138.127.255",
            "destIP": "175.0.255.255",
            "srcPort": 449,
            "destPort": 425,
            "srcXY": ["34.9895", "32.79"],
            "destXY": ["113.082", "28.256"],
            "time": 1479092713000,
            "warnningTypeID": 9,
            "srcCountryID": "IL",
            "destCountryID": "CN",
            "oneDay_Count": 7,
            "servenDay_Count": 55,
            "month_Count": 220,
            "deviceID": "4340079686",
            "srcID": "FHT:1739668149640735300",
            "desID": "FHT:6286603936251775468",
            "threatID": "0"
        },
        {
            "protoType": "udp",
            "deviceType": 3,
            "warnningSource": "deivce",
            "srcCountry": "俄罗斯",
            "destCountry": "西班牙",
            "srcCity": "",
            "destCity": "Madrid",
            "srcIP": "94.25.186.255",
            "destIP": "213.96.96.255",
            "srcPort": 440,
            "destPort": 441,
            "srcXY": ["37.6173", "55.755"],
            "destXY": ["-3.70379", "40.416"],
            "time": 1479092711000,
            "warnningTypeID": 13,
            "srcCountryID": "RU",
            "destCountryID": "ES",
            "oneDay_Count": 2,
            "servenDay_Count": 16,
            "month_Count": 62,
            "deviceID": "1093522771",
            "srcID": "FHT:1147215337022217640",
            "desID": "FHT:5486835675961739349",
            "threatID": "0"
        },
        {
            "protoType": "udp",
            "deviceType": 3,
            "warnningSource": "deivce",
            "srcCountry": "埃及",
            "destCountry": "希腊",
            "srcCity": "",
            "destCity": "雅典",
            "srcIP": "196.218.255.255",
            "destIP": "83.235.96.255",
            "srcPort": 405,
            "destPort": 492,
            "srcXY": ["31.2357", "30.044"],
            "destXY": ["23.7275", "37.983"],
            "time": 1479092709000,
            "warnningTypeID": 6,
            "srcCountryID": "JO",
            "destCountryID": "GR",
            "oneDay_Count": 6,
            "servenDay_Count": 43,
            "month_Count": 208,
            "deviceID": "7084558926",
            "srcID": "FHT:6101560631397102309",
            "desID": "FHT:4058945515871380182",
            "threatID": "0"
        },
        {
            "protoType": "udp",
            "deviceType": 3,
            "warnningSource": "deivce",
            "srcCountry": "日本",
            "destCountry": "中国",
            "srcCity": "",
            "destCity": "十堰",
            "srcIP": "61.201.255.255",
            "destIP": "183.92.64.255",
            "srcPort": 474,
            "destPort": 493,
            "srcXY": ["135.563", "34.641"],
            "destXY": ["110.798", "32.629"],
            "time": 1479092686000,
            "warnningTypeID": 8,
            "srcCountryID": "JP",
            "destCountryID": "CN",
            "oneDay_Count": 0,
            "servenDay_Count": 6,
            "month_Count": 11,
            "deviceID": "4738616440",
            "srcID": "FHT:536578966958268585",
            "desID": "FHT:1441315403005034256",
            "threatID": "0"
        },
        {
            "protoType": "tcp",
            "deviceType": 4,
            "warnningSource": "deivce",
            "srcCountry": "中国",
            "destCountry": "西班牙",
            "srcCity": "",
            "destCity": "Madrid",
            "srcIP": "61.166.150.138",
            "destIP": "213.96.96.255",
            "srcPort": 405,
            "destPort": 486,
            "srcXY": ["102.92", "25.466"],
            "destXY": ["-3.70379", "40.416"],
            "time": 1479092684000,
            "warnningTypeID": 11,
            "srcCountryID": "CN",
            "destCountryID": "ES",
            "oneDay_Count": 9,
            "servenDay_Count": 65,
            "month_Count": 277,
            "deviceID": "8015704893",
            "srcID": "FHT:5642363749312547986",
            "desID": "FHT:5763111136707783424",
            "threatID": "0"
        }],
        "size": 10,
        "code": 200
    }
    function convertToTimeBins(sData) {
        var timeBins = [{
            "data": []
        }]
        for (var i = 0; i < sData.length; i++) {
            timeBins[0].data[i] = {};
            timeBins[0].data[i].i = countryLookup[sData[i].srcCountryID];
            timeBins[0].data[i].e = countryLookup[sData[i].destCountryID];
            timeBins[0].data[i].v = 1000;
        };
        return timeBins;
    }
    var timeBins = convertToTimeBins(lxcData.lst);
    var timeBins1 = [{
        "data": [{
            "i": "Algeria",
            "e": "Australia",
            "v": 2479
        },
        {
            "i": "New Zealand",
            "e": "Australia",
            "v": 1986
        },
        {
            "i": "Singapore",
            "e": "Australia",
            "v": 1233210
        },
        {
            "i": "United Kingdom",
            "e": "Australia",
            "v": 37576
        },
        ]
    }];
    var masterContainer = document.getElementById('visualization');
    var overlay = document.getElementById('visualization');
    var mapIndexedImage;
    var mapOutlineImage;
    var camera, scene, renderer;
    var lookupCanvas;
    var lookupTexture;
    var rotating;
    var visualizationMesh;
    var mapUniforms;
    var countryData = new Object();
    loadGeoData(latlonData);
    function loadGeoData(latlonData) {
        var sphereRad = 1;
        var rad = 100;
        for (var i in latlonData.countries) {
            var country = latlonData.countries[i];
            country.countryCode = i;
            country.countryName = countryLookup[i];
            var lon = country.lon - 90;
            var lat = country.lat;
            var phi = Math.PI / 2 - lat * Math.PI / 180 - Math.PI * 0.01;
            var theta = 2 * Math.PI - lon * Math.PI / 180 + Math.PI * 0.06;
            var center = new THREE.Vector3();
            center.x = Math.sin(phi) * Math.cos(theta) * rad;
            center.y = Math.cos(phi) * rad;
            center.z = Math.sin(phi) * Math.sin(theta) * rad;
            country.center = center;
            countryData[country.countryName] = country
        }
    }
    function loadGeoData2() {
        var sphereRad = 1;
        var rad = 100;
        for (var i in lxcData.lst) {
            lxcData.lst[i].start3DPosition = set3DXYZ(lxcData.lst[i].srcXY);
            lxcData.lst[i].end3DPosition = set3DXYZ(lxcData.lst[i].destXY);
        }
        function set3DXYZ(xyArray) {
            var lon = xyArray[0] - 90;
            var lat = xyArray[1];
            var phi = Math.PI / 2 - lat * Math.PI / 180 - Math.PI * 0.01;
            var theta = 2 * Math.PI - lon * Math.PI / 180 + Math.PI * 0.06;
            var center = new THREE.Vector3();
            center.x = Math.sin(phi) * Math.cos(theta) * rad;
            center.y = Math.cos(phi) * rad;
            center.z = Math.sin(phi) * Math.sin(theta) * rad;
            return center;
        }
    }
    loadGeoData2();
    var selectableCountries = [];
    var allCountries = [];
    for (var i in countryLookup) {
        allCountries.push(countryLookup[i])
    }
    for (var i in timeBins) {
        var bin = timeBins[i].data;
        for (var s in bin) {
            var set = bin[s];
            var exporterName = set.e.toUpperCase();
            var importerName = set.i.toUpperCase();
            if ($.inArray(exporterName, selectableCountries) < 0) selectableCountries.push(exporterName);
            if ($.inArray(importerName, selectableCountries) < 0) selectableCountries.push(importerName);
        }
    }
    var cwidth = $('#earthArea').width();
    var cheight = $('#earthArea').height();
    var selectedCountry = null;
    var previouslySelectedCountry = null;
    var selectionData;
    var dragging = false;
    var rotateVX = 0,
    rotateVY = 0;
    var rotateXMax = 90 * Math.PI / 180;
    var rotateTargetX = undefined;
    var rotateTargetY = undefined;
    var keyboard = new THREEx.KeyboardState();
    var rotateX = 0,
    rotateY = 0;
    var markers = [];
    var EarthModel = {
        init: function() {
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = (function() {
                    return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
                    function(callback, element) {
                        window.setTimeout(callback, 1000 / 60)
                    }
                })()
            }
            start();
            function start(e) {
                if (!Detector.webgl) {
                    Detector.addGetWebGLMessage()
                } else {
                    mapIndexedImage = new Image();
                    mapIndexedImage.src = 'images/map_indexed.png';
                    mapIndexedImage.onload = function() {
                        mapOutlineImage = new Image();
                        mapOutlineImage.src = 'images/map_outline.png';
                        mapOutlineImage.onload = function() {
                            initScene();
                            animate()
                        }
                    }
                }
            }
            function initScene() {
                scene = new THREE.Scene();
                scene.matrixAutoUpdate = false;
                scene.add(new THREE.AmbientLight(0x505050));
                rotating = new THREE.Object3D();
                scene.add(rotating);
                lookupCanvas = document.createElement('canvas');
                lookupCanvas.width = 256;
                lookupCanvas.height = 1;
                lookupTexture = new THREE.Texture(lookupCanvas);
                lookupTexture.magFilter = THREE.NearestFilter;
                lookupTexture.minFilter = THREE.NearestFilter;
                lookupTexture.needsUpdate = true;
                var indexedMapTexture = new THREE.Texture(mapIndexedImage);
                indexedMapTexture.needsUpdate = true;
                indexedMapTexture.magFilter = THREE.NearestFilter;
                indexedMapTexture.minFilter = THREE.NearestFilter;
                var outlinedMapTexture = new THREE.Texture(mapOutlineImage);
                outlinedMapTexture.needsUpdate = true;
                var uniforms = {
                    'mapIndex': {
                        type: 't',
                        value: 0,
                        texture: indexedMapTexture
                    },
                    'lookup': {
                        type: 't',
                        value: 1,
                        texture: lookupTexture
                    },
                    'outline': {
                        type: 't',
                        value: 2,
                        texture: outlinedMapTexture
                    },
                    'outlineLevel': {
                        type: 'f',
                        value: 1
                    },
                };
                mapUniforms = uniforms;
                var shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: document.getElementById('globeVertexShader').textContent,
                    fragmentShader: document.getElementById('globeFragmentShader').textContent,
                });
                var sphere = new THREE.Mesh(new THREE.SphereGeometry(100, 40, 40), shaderMaterial);
                sphere.doubleSided = false;
                sphere.rotation.x = Math.PI;
                sphere.rotation.y = -Math.PI / 2;
                sphere.rotation.z = Math.PI;
                sphere.id = "base";
                rotating.add(sphere);
                EarthModel.buildDataVizGeometries(timeBins[0].data);
                EarthModel.buildDataVizGeometries1(lxcData.lst);
                visualizationMesh = new THREE.Object3D();
                rotating.add(visualizationMesh);
                var Selection = function() {
                    this.exportCategories = new Object();
                    this.importCategories = new Object();
                    this.getExportCategories = function() {
                        var list = [];
                        for (var i in this.exportCategories) {
                            if (this.exportCategories[i]) list.push(i)
                        }
                        return list
                    }
                    this.getImportCategories = function() {
                        var list = [];
                        for (var i in this.importCategories) {
                            if (this.importCategories[i]) list.push(i)
                        }
                        return list
                    }
                };
                selectionData = new Selection();
                //EarthModel.selectVisualization(timeBins, ['CHINA']);
                
                EarthModel.selectVisualization1(lxcData.lst, 'CHINA');
                
                renderer = new THREE.WebGLRenderer({
                    antialias: false
                });
                renderer.setSize(cwidth, cheight);
                renderer.autoClear = false;
                renderer.sortObjects = false;
                renderer.generateMipmaps = false;
                document.getElementById('earthArea').appendChild(renderer.domElement);
                var mouseX = 0,
                mouseY = 0,
                pmouseX = 0,
                pmouseY = 0;
                var pressX = 0,
                pressY = 0;
                function onDocumentMouseMove(event) {
                    pmouseX = mouseX;
                    pmouseY = mouseY;
                    mouseX = event.clientX - cwidth * 0.5;
                    mouseY = event.clientY - cheight * 0.5;
                    if (dragging) {
                        if (keyboard.pressed("shift") == false) {
                            rotateVY += (mouseX - pmouseX) / 2 * Math.PI / 180 * 0.3;
                            rotateVX += (mouseY - pmouseY) / 2 * Math.PI / 180 * 0.3
                        } else {
                            camera.position.x -= (mouseX - pmouseX) * .5;
                            camera.position.y += (mouseY - pmouseY) * .5
                        }
                    }
                }
                function onDocumentMouseDown(event) {
                    if (event.target.className.indexOf('noMapDrag') !== -1) {
                        return
                    }
                    dragging = true;
                    pressX = mouseX;
                    pressY = mouseY;
                    rotateTargetX = undefined;
                    rotateTargetX = undefined
                }
                function onDocumentMouseUp(event) {
                    dragging = false;
                    histogramPressed = false
                }
                function onClick(event) {
                    if (Math.abs(pressX - mouseX) > 3 || Math.abs(pressY - mouseY) > 3) {
                        return
                    }
                    function getPickColor() {
                        var affectedCountries = undefined;
                        if (visualizationMesh.children[0] !== undefined) {
                            affectedCountries = visualizationMesh.children[0].affectedCountries
                        }
                        rotating.remove(visualizationMesh);
                        mapUniforms['outlineLevel'].value = 0;
                        lookupTexture.needsUpdate = true;
                        renderer.autoClear = false;
                        renderer.autoClearColor = false;
                        renderer.autoClearDepth = false;
                        renderer.autoClearStencil = false;
                        renderer.preserve;
                        renderer.clear();
                        renderer.render(scene, camera);
                        var gl = renderer.context;
                        gl.preserveDrawingBuffer = true;
                        var mx = (mouseX + renderer.context.canvas.width / 2);
                        var my = ( - mouseY + renderer.context.canvas.height / 2);
                        mx = Math.floor(mx);
                        my = Math.floor(my);
                        var buf = new Uint8Array(4);
                        gl.readPixels(mx, my, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, buf);
                        renderer.autoClear = true;
                        renderer.autoClearColor = true;
                        renderer.autoClearDepth = true;
                        renderer.autoClearStencil = true;
                        gl.preserveDrawingBuffer = false;
                        mapUniforms['outlineLevel'].value = 1;
                        rotating.add(visualizationMesh);
                        if (affectedCountries !== undefined) {}
                        return buf[0]
                    }
                    var pickColorIndex = getPickColor();
                    //lxcData
                    console.log(pickColorIndex);
                    var selectedLocation = getCountryFromColorIndex(pickColorIndex);
                    function getCountryFromColorIndex(pickColorIndex) {
                        for (var i in countryColorMap) {
                            if (countryColorMap[i] == pickColorIndex) {
                                return countryLookup[i];
                            };
                        }
                    }
                    EarthModel.selectVisualization1(lxcData.lst, selectedLocation);
                    //EarthModel.selectVisualization(timeBins, [selectedLocation]);
                    // for (var i in countryColorMap) {
                    //     var countryCode = i;
                    //     var countryColorIndex = countryColorMap[i];
                    //     if (pickColorIndex == countryColorIndex) {
                    //         var countryName = countryLookup[countryCode];
                    //         if (countryName === undefined) {
                    //             return
                    //         }
                    //         var selection = selectionData;
                    //         selection.selectedCountry = countryName;
                    //         console.log(selection.selectedCountry);
                    //         //EarthModel.selectVisualization(timeBins, [selection.selectedCountry]);
                    //         return;
                    //     }
                    // }
                }
                function onMouseWheel(event) {
                    var delta = 0;
                    if (event.wheelDelta) {
                        delta = event.wheelDelta / 120
                    } else if (event.detail) {
                        delta = -event.detail / 3
                    }
                    function handleMWheel(delta) {
                        camera.scale.z += delta * 0.1;
                        camera.scale.z = constrain(camera.scale.z, 0.7, 5.0)
                    }
                    if (delta) {
                        handleMWheel(delta)
                    }
                    event.returnValue = false
                }
                document.addEventListener('mousemove', onDocumentMouseMove, true);
                document.addEventListener('mousedown', onDocumentMouseDown, true);
                document.addEventListener('mouseup', onDocumentMouseUp, false);
                masterContainer.addEventListener('click', onClick, true);
                masterContainer.addEventListener('mousewheel', onMouseWheel, false);
                masterContainer.addEventListener('DOMMouseScroll',
                function(e) {
                    var evt = window.event || e;
                    onMouseWheel(evt)
                },
                false);
                camera = new THREE.PerspectiveCamera(12, cwidth / cheight, 1, 20000);
                camera.position.z = 1400;
                camera.position.y = 0;
                scene.add(camera);
                var windowResize = THREEx.WindowResize(renderer, camera)
            }
            function animate() {
                if (rotateTargetX !== undefined && rotateTargetY !== undefined) {
                    rotateVX += (rotateTargetX - rotateX) * 0.012;
                    rotateVY += (rotateTargetY - rotateY) * 0.012;
                    if (Math.abs(rotateTargetX - rotateX) < 0.1 && Math.abs(rotateTargetY - rotateY) < 0.1) {
                        rotateTargetX = undefined;
                        rotateTargetY = undefined
                    }
                }
                rotateX += rotateVX;
                rotateY += rotateVY;
                rotateVX *= 0.98;
                rotateVY *= 0.98;
                if (dragging || rotateTargetX !== undefined) {
                    rotateVX *= 0.6;
                    rotateVY *= 0.6
                }
                if (rotateX < -rotateXMax) {
                    rotateX = -rotateXMax;
                    rotateVX *= -0.95
                }
                if (rotateX > rotateXMax) {
                    rotateX = rotateXMax;
                    rotateVX *= -0.95
                }
                rotating.rotation.x = rotateX;
                rotating.rotation.y = rotateY;
                renderer.clear();
                renderer.render(scene, camera);
                requestAnimationFrame(animate)
                // THREE.SceneUtils.traverseHierarchy(rotating,
                // function(mesh) {
                //     if (mesh.update !== undefined) {
                //         mesh.update()
                //     }
                // });
                for (var i in markers) {
                    var marker = markers[i];
                    marker.update()
                }
            }
        },
        run: function() {
            EarthModel.init()
        },
        buildDataVizGeometries1: function(linearData) { //画线模块
            for (var i = 0; i < linearData.length; i++) {
                linearData[i].lineGeometry = makeConnectionLineGeometry(linearData[i].end3DPosition, linearData[i].start3DPosition, 100);
            };
            function makeConnectionLineGeometry(exporter, importer, value) {
                var globeRadius = 1000;
                var vec3_origin = new THREE.Vector3(0, 0, 0);
                var distanceBetweenCountryCenter = exporter.clone().subSelf(importer).length();
                var anchorHeight = globeRadius + distanceBetweenCountryCenter * 0.7;
                var start = exporter;
                var end = importer;
                var mid = start.clone().lerpSelf(end, 0.5);
                var midLength = mid.length();
                mid.normalize();
                mid.multiplyScalar(midLength + distanceBetweenCountryCenter * 0.7);
                var normal = (new THREE.Vector3()).sub(start, end);
                normal.normalize();
                var distanceHalf = distanceBetweenCountryCenter * 0.5;
                var startAnchor = start;
                var midStartAnchor = mid.clone().addSelf(normal.clone().multiplyScalar(distanceHalf));
                var midEndAnchor = mid.clone().addSelf(normal.clone().multiplyScalar( - distanceHalf));
                var endAnchor = end;
                var splineCurveA = new THREE.CubicBezierCurve3(start, startAnchor, midStartAnchor, mid);
                var splineCurveB = new THREE.CubicBezierCurve3(mid, midEndAnchor, endAnchor, end);
                var vertexCountDesired = Math.floor(distanceBetweenCountryCenter * 0.02 + 6) * 2;
                var points = splineCurveA.getPoints(vertexCountDesired);
                points = points.splice(0, points.length - 1);
                points = points.concat(splineCurveB.getPoints(vertexCountDesired));
                points.push(vec3_origin);
                var val = value * 0.0003;
                var size = (10 + Math.sqrt(val));
                size = constrain(size, 0.1, 60);

                THREE.Curve.Utils.createLineGeometry = function(points) {
                    var geometry = new THREE.Geometry();
                    for (var i = 0; i < points.length; i++) {
                        geometry.vertices.push(points[i])
                    }
                    return geometry;
                };
                var curveGeometry = THREE.Curve.Utils.createLineGeometry(points);
                curveGeometry.size = size;
                return curveGeometry;
            }
        },
        buildDataVizGeometries: function(linearData) { //画线模块
            for (var s in linearData) {
                var set = linearData[s];
                var exporterName = set.e.toUpperCase();
                var importerName = set.i.toUpperCase();
                exporter = countryData[exporterName];
                importer = countryData[importerName];
                if (exporter === undefined || importer === undefined) {
                    continue
                }
                set.lineGeometry = makeConnectionLineGeometry(exporter, importer, set.v)
            }
            function makeConnectionLineGeometry(exporter, importer, value) {
                var globeRadius = 1000;
                var vec3_origin = new THREE.Vector3(0, 0, 0);
                if (exporter.countryName == undefined || importer.countryName == undefined) return undefined;
                var distanceBetweenCountryCenter = exporter.center.clone().subSelf(importer.center).length();
                var anchorHeight = globeRadius + distanceBetweenCountryCenter * 0.7;
                var start = exporter.center;
                var end = importer.center;
                var mid = start.clone().lerpSelf(end, 0.5);
                var midLength = mid.length();
                mid.normalize();
                mid.multiplyScalar(midLength + distanceBetweenCountryCenter * 0.7);
                var normal = (new THREE.Vector3()).sub(start, end);
                normal.normalize();
                var distanceHalf = distanceBetweenCountryCenter * 0.5;
                var startAnchor = start;
                var midStartAnchor = mid.clone().addSelf(normal.clone().multiplyScalar(distanceHalf));
                var midEndAnchor = mid.clone().addSelf(normal.clone().multiplyScalar( - distanceHalf));
                var endAnchor = end;
                var splineCurveA = new THREE.CubicBezierCurve3(start, startAnchor, midStartAnchor, mid);
                var splineCurveB = new THREE.CubicBezierCurve3(mid, midEndAnchor, endAnchor, end);
                var vertexCountDesired = Math.floor(distanceBetweenCountryCenter * 0.02 + 6) * 2;
                var points = splineCurveA.getPoints(vertexCountDesired);
                points = points.splice(0, points.length - 1);
                points = points.concat(splineCurveB.getPoints(vertexCountDesired));
                points.push(vec3_origin);
                var val = value * 0.0003;
                var size = (10 + Math.sqrt(val));
                size = constrain(size, 0.1, 60);
                THREE.Curve.Utils.createLineGeometry = function(points) {
                    var geometry = new THREE.Geometry();
                    for (var i = 0; i < points.length; i++) {
                        geometry.vertices.push(points[i])
                    }
                    return geometry
                };
                var curveGeometry = THREE.Curve.Utils.createLineGeometry(points);
                curveGeometry.size = size;
                return curveGeometry;
            }
        },
        selectVisualization1: function(linearData, countryNow) { //未知，需要处理
            //selectedCountry = countryData[countries[0].toUpperCase()];
            var perviousCountry = selectedCountry||null;
                //处理代码写这里
                //在数据上移除所有可选择的国家,由于咱们所有可选国家都是在每次获取数据后定的故这里不改
                // for (var i in selectableCountries) {
                //     removeMarkerFromCountry(selectableCountries[i]);
                // }
                //
                //移除Three.js上的所以线的子函数，这里移除后界面立即生效了，说明Three.js的配置数据和界面显示是实时绑定的
                //visualizationMesh.children=[];这里必须使用remove函数来移除指定的内容，故使用了递归
                while (visualizationMesh.children.length > 0) {
                    var c = visualizationMesh.children[0];
                    visualizationMesh.remove(c)
                }
                //这里要做的：显示和被点击区域有关的所有线条/和标签？？？？
                var mesh = getVisualizedMesh(linearData, countryNow);
                visualizationMesh.add(mesh);
                if (mesh.affectedCountries.length == 0) {
                    mesh.affectedCountries.push(countryNow);
                }
            for (var i in mesh.affectedCountries) {
                var countryName = mesh.affectedCountries[i];
                var country = countryData[countryName];

                attachMarkerToCountry(countryName, country.mapColor);
            }          
            selectedCountry=countryData[countryNow];
            EarthModel.highlightCountry(countryNow);
            function removeMarkerFromCountry(countryName) {
                countryName = countryName.toUpperCase();
                var country = countryData[countryName];
                if (country === undefined) return;
                if (country.marker === undefined) return;
                var index = markers.indexOf(country.marker);
                if (index >= 0) markers.splice(index, 1);
                var container = document.getElementById('visualization');
                container.removeChild(country.marker);
                country.marker = undefined;
            }
            function getVisualizedMesh(linearData, countryNow) {
                var affectedCountries = [];
                var selectedLineData = [];
                var linesGeo = new THREE.Geometry();
                var lineColors = [];
                var particlesGeo = new THREE.Geometry();
                var particleColors = [];
                for (var i = 0; i < linearData.length; i++) {
                    var srcCountry = countryLookup[linearData[i].srcCountryID];
                    var destCountry = countryLookup[linearData[i].destCountryID];
                    if (srcCountry == countryNow || destCountry == countryNow) {
                        selectedLineData.push(linearData[i]);
                    };
                };
                if (selectedLineData.length == 0) {
                    return;
                };
                for (var i = 0; i < selectedLineData.length; i++) {
                    var lineColor = new THREE.Color(0xdd380c);
                    for (s in selectedLineData[i].lineGeometry.vertices) {
                        lineColors.push(lineColor);
                    }
                    THREE.GeometryUtils.merge(linesGeo, selectedLineData[i].lineGeometry);
                    var particleColor = lineColor.clone();
                    var points = set.lineGeometry.vertices;
                    var particleCount = Math.floor(set.v / 8000 / set.lineGeometry.vertices.length) + 1;
                    particleCount = constrain(particleCount, 1, 100);
                    var particleSize = set.lineGeometry.size;
                    for (var s = 0; s < particleCount; s++) {
                        var desiredIndex = s / particleCount * points.length;
                        var rIndex = constrain(Math.floor(desiredIndex), 0, points.length - 1);
                        var point = points[rIndex];
                        var particle = point.clone();
                        particle.moveIndex = rIndex;
                        particle.nextIndex = rIndex + 1;
                        if (particle.nextIndex >= points.length) particle.nextIndex = 0;
                        particle.lerpN = 0;
                        particle.path = points;
                        particlesGeo.vertices.push(particle);
                        particle.size = particleSize;
                        particleColors.push(particleColor)
                    }
                };
                //----------  线 Start Written by Lxc ----------
                linesGeo.colors = lineColors;
                //线上的特效开始
                var splineOutline = new THREE.Line(linesGeo, new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false,
                    vertexColors: true,
                    linewidth: 1
                }));
                splineOutline.renderDepth = false;
                attributes = {
                    size: {
                        type: 'f',
                        value: []
                    },
                    customColor: {
                        type: 'c',
                        value: []
                    }
                };
                uniforms = {
                    amplitude: {
                        type: "f",
                        value: 1.0
                    },
                    color: {
                        type: "c",
                        value: new THREE.Color(0xffffff)
                    },
                    texture: {
                        type: "t",
                        value: 0,
                        texture: THREE.ImageUtils.loadTexture("images/particleA.png")
                    },
                };
                var shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    attributes: attributes,
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    blending: THREE.AdditiveBlending,
                    depthTest: true,
                    depthWrite: false,
                    transparent: true,
                });
                var particleGraphic = THREE.ImageUtils.loadTexture("images/map_mask.png");
                var particleMat = new THREE.ParticleBasicMaterial({
                    map: particleGraphic,
                    color: 0xffffff,
                    size: 60,
                    blending: THREE.NormalBlending,
                    transparent: true,
                    depthWrite: false,
                    vertexColors: true,
                    sizeAttenuation: true
                });
                particlesGeo.colors = particleColors;
                var pSystem = new THREE.ParticleSystem(particlesGeo, shaderMaterial);
                pSystem.dynamic = true;
                splineOutline.add(pSystem);
                //线上的特效结束
                var vertices = pSystem.geometry.vertices;
                var values_size = attributes.size.value;
                var values_color = attributes.customColor.value;
                for (var v = 0; v < vertices.length; v++) {
                    values_size[v] = pSystem.geometry.vertices[v].size;
                    values_color[v] = particleColors[v]
                }
                pSystem.update = function() {
                    for (var i in this.geometry.vertices) {
                        var particle = this.geometry.vertices[i];
                        var path = particle.path;
                        var moveLength = path.length;
                        particle.lerpN += 0.05;
                        if (particle.lerpN > 1) {
                            particle.lerpN = 0;
                            particle.moveIndex = particle.nextIndex;
                            particle.nextIndex++;
                            if (particle.nextIndex >= path.length) {
                                particle.moveIndex = 0;
                                particle.nextIndex = 1
                            }
                        }
                        var currentPoint = path[particle.moveIndex];
                        var nextPoint = path[particle.nextIndex];
                        particle.copy(currentPoint);
                        particle.lerpSelf(nextPoint, particle.lerpN)
                    }
                    this.geometry.verticesNeedUpdate = true
                };
                splineOutline.affectedCountries = affectedCountries;
                return splineOutline;
            }
            function attachMarkerToCountry(countryName, importance) {
                countryName = countryName.toUpperCase();
                console.log(selectedCountry);
                var country = countryData[countryName];
                if (country === undefined) return;
                var container = document.getElementById('visualization');
                var template = document.getElementById('marker_template');
                var marker = template.cloneNode(true);
                country.marker = marker;
                container.appendChild(marker);

                marker.countryName = countryName;
                marker.importance = importance;
                marker.selected = false;
                marker.hover = false;
                // if (countryName === selectedCountry.countryName.toUpperCase()) {
                //     marker.selected = true;
                // }
                marker.selected = true;
                marker.setPosition = function(x, y, z) {
                    this.style.left = x + 'px';
                    this.style.top = y + 'px';
                    this.style.zIndex = z
                }
                marker.setVisible = function(vis) {
                    if (!vis) this.style.display = 'none';
                    else {
                        this.style.display = 'inline'
                    }
                }
                var countryLayer = marker.querySelector('#countryText');
                marker.countryLayer = countryLayer;
                var detailLayer = marker.querySelector('#detailText');
                marker.detailLayer = detailLayer;
                marker.jquery = $(marker);
                marker.setSize = function(s) {
                    var detailSize = Math.floor(2 + s * 0.5);
                    this.detailLayer.style.fontSize = 10 + 'pt';
                    var totalHeight = detailSize * 2;
                    this.style.fontSize = 10 + 'pt';
                    if (detailSize <= 8) {
                        this.countryLayer.style.marginTop = "0px"
                    } else {
                        this.countryLayer.style.marginTop = "-1px"
                    }
                }
                marker.update = function() {
                    var matrix = rotating.matrixWorld;
                    var abspos = matrix.multiplyVector3(country.center.clone());
                    var screenPos = screenXY(abspos);
                    var s = 0.3 + camera.scale.z * 1;
                    var importanceScale = this.importance / 5000000;
                    importanceScale = constrain(importanceScale, 0, 18);
                    s += importanceScale;
                    if (this.tiny) s *= 0.75;
                    if (this.selected) s = 30;
                    if (this.hover) s = 15;
                    this.setSize(s);
                    this.setVisible((abspos.z > 60) && s > 3);
                    var zIndex = Math.floor(1000 - abspos.z + s);
                    if (this.selected || this.hover) zIndex = 10000;
                    this.setPosition(screenPos.x, screenPos.y, zIndex);
                    function screenXY(vec3) {
                        var projector = new THREE.Projector();
                        var vector = projector.projectVector(vec3.clone(), camera);
                        var result = new Object();
                        var windowWidth = cwidth;
                        result.x = Math.round(vector.x * (windowWidth / 2)) + windowWidth / 2;
                        result.y = Math.round((0 - vector.y) * (cheight / 2)) + cheight / 2;
                        return result;
                    }
                }
                var nameLayer = marker.querySelector('#countryText');
                var tiny = (importance < 20000000) && (!marker.selected);
                marker.tiny = tiny;
                nameLayer.innerHTML = countryName.replace(' ', '&nbsp;');
                var importExportText = "这里显示各种内容";
                if (country.exportedAmount > 0 && country.importedAmount > 0) {
                    importExportText += "攻击类型:&nbsp;" + numberWithCommas(country.importedAmount) + "<br />设备类型:&nbsp;" + numberWithCommas(country.exportedAmount)
                } else if (country.exportedAmount > 0 && country.importedAmount == 0) {
                    importExportText += "设备类型:&nbsp;" + numberWithCommas(country.exportedAmount) + "<br />&nbsp;"
                } else if (country.exportedAmount == 0 && country.importedAmount > 0) {
                    importExportText += "攻击类型:&nbsp;" + numberWithCommas(country.importedAmount) + "<br />&nbsp;"
                }
                function numberWithCommas(x) {
                    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
                }
                marker.importExportText = importExportText;
                var markerOver = function(e) {
                    this.detailLayer.innerHTML = importExportText;
                    this.hover = true
                }
                var markerOut = function(e) {
                    this.detailLayer.innerHTML = "";
                    this.hover = false;
                }
                if (!tiny) {
                    detailLayer.innerHTML = importExportText;
                } else {
                    marker.addEventListener('mouseover', markerOver, false);
                    marker.addEventListener('mouseout', markerOut, false)
                }
                var markerSelect = function(e) {
                    alert("这里显示具体信息");
                    var selection = selectionData;
                    //EarthModel.selectVisualization(timeBins, [selection.selectedCountry]);
                    //EarthModel.selectVisualization(timeBins,  [this.countryName], selection.getExportCategories(), selection.getImportCategories())
                };
                marker.addEventListener('click', markerSelect, true);
                markers.push(marker);
            }
        },
        selectVisualization: function(linearData, countries) { //未知，需要处理
            var cName = countries[0].toUpperCase();

            previouslySelectedCountry = selectedCountry;
            selectedCountry = countryData[countries[0].toUpperCase()];

            for (var i in selectableCountries) {
                removeMarkerFromCountry(selectableCountries[i])
            }

            while (visualizationMesh.children.length > 0) {
                var c = visualizationMesh.children[0];
                visualizationMesh.remove(c)
            }
            var mesh = getVisualizedMesh(timeBins, countries);
            visualizationMesh.add(mesh);
            
            if (mesh.affectedCountries.length == 0) {
                mesh.affectedCountries.push(cName)
            }
            console.log(mesh.affectedCountries);
            for (var i in mesh.affectedCountries) {
                var countryName = mesh.affectedCountries[i];
                var country = countryData[countryName];
                attachMarkerToCountry(countryName, country.mapColor);
            }
            //EarthModel.highlightCountry(mesh.affectedCountries);
            EarthModel.highlightCountry(countries[0]);
            if (previouslySelectedCountry !== selectedCountry) {
                if (selectedCountry) {
                    rotateTargetX = selectedCountry.lat * Math.PI / 180;
                    var targetY0 = -(selectedCountry.lon - 9) * Math.PI / 180;
                    var piCounter = 0;
                    while (true) {
                        var targetY0Neg = targetY0 - Math.PI * 2 * piCounter;
                        var targetY0Pos = targetY0 + Math.PI * 2 * piCounter;
                        if (Math.abs(targetY0Neg - rotating.rotation.y) < Math.PI) {
                            rotateTargetY = targetY0Neg;
                            break
                        } else if (Math.abs(targetY0Pos - rotating.rotation.y) < Math.PI) {
                            rotateTargetY = targetY0Pos;
                            break
                        }
                        piCounter++;
                        rotateTargetY = wrap(targetY0, -Math.PI, Math.PI)
                    }
                    rotateVX *= 0.6;
                    rotateVY *= 0.6;
                    function wrap(value, min, rangeSize) {
                        rangeSize -= min;
                        while (value < min) {
                            value += rangeSize
                        }
                        return value % rangeSize
                    }
                }
            }
            function getVisualizedMesh(linearData, year, countries) {
                for (var i in countries) {
                    countries[i] = countries[i].toUpperCase()
                }
                var affectedCountries = [];
                var bin = linearData[0].data;
                var linesGeo = new THREE.Geometry();
                var lineColors = [];
                var particlesGeo = new THREE.Geometry();
                var particleColors = [];
                for (i in bin) {
                    var set = bin[i];
                    var lineColor = new THREE.Color(0xdd380c);
                    for (s in set.lineGeometry.vertices) {
                        lineColors.push(lineColor);
                    }
                    THREE.GeometryUtils.merge(linesGeo, bin[i].lineGeometry);
                    var particleColor = lineColor.clone();
                    var points = set.lineGeometry.vertices;
                    var particleCount = Math.floor(set.v / 8000 / set.lineGeometry.vertices.length) + 1;
                    particleCount = constrain(particleCount, 1, 100);
                    var particleSize = set.lineGeometry.size;
                    for (var s = 0; s < particleCount; s++) {
                        var desiredIndex = s / particleCount * points.length;
                        var rIndex = constrain(Math.floor(desiredIndex), 0, points.length - 1);
                        var point = points[rIndex];
                        var particle = point.clone();
                        particle.moveIndex = rIndex;
                        particle.nextIndex = rIndex + 1;
                        if (particle.nextIndex >= points.length) particle.nextIndex = 0;
                        particle.lerpN = 0;
                        particle.path = points;
                        particlesGeo.vertices.push(particle);
                        particle.size = particleSize;
                        particleColors.push(particleColor);
                    }
                }
                linesGeo.colors = lineColors;
                //线上的特效开始
                var splineOutline = new THREE.Line(linesGeo, new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false,
                    vertexColors: true,
                    linewidth: 1
                }));
                splineOutline.renderDepth = false;
                attributes = {
                    size: {
                        type: 'f',
                        value: []
                    },
                    customColor: {
                        type: 'c',
                        value: []
                    }
                };
                uniforms = {
                    amplitude: {
                        type: "f",
                        value: 1.0
                    },
                    color: {
                        type: "c",
                        value: new THREE.Color(0xffffff)
                    },
                    texture: {
                        type: "t",
                        value: 0,
                        texture: THREE.ImageUtils.loadTexture("images/particleA.png")
                    },
                };
                var shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    attributes: attributes,
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    blending: THREE.AdditiveBlending,
                    depthTest: true,
                    depthWrite: false,
                    transparent: true,
                });
                var particleGraphic = THREE.ImageUtils.loadTexture("images/map_mask.png");
                var particleMat = new THREE.ParticleBasicMaterial({
                    map: particleGraphic,
                    color: 0xffffff,
                    size: 60,
                    blending: THREE.NormalBlending,
                    transparent: true,
                    depthWrite: false,
                    vertexColors: true,
                    sizeAttenuation: true
                });
                particlesGeo.colors = particleColors;
                var pSystem = new THREE.ParticleSystem(particlesGeo, shaderMaterial);
                pSystem.dynamic = true;
                splineOutline.add(pSystem);
                //线上的特效结束
                var vertices = pSystem.geometry.vertices;
                var values_size = attributes.size.value;
                var values_color = attributes.customColor.value;
                for (var v = 0; v < vertices.length; v++) {
                    values_size[v] = pSystem.geometry.vertices[v].size;
                    values_color[v] = particleColors[v]
                }
                pSystem.update = function() {
                    for (var i in this.geometry.vertices) {
                        var particle = this.geometry.vertices[i];
                        var path = particle.path;
                        var moveLength = path.length;
                        particle.lerpN += 0.05;
                        if (particle.lerpN > 1) {
                            particle.lerpN = 0;
                            particle.moveIndex = particle.nextIndex;
                            particle.nextIndex++;
                            if (particle.nextIndex >= path.length) {
                                particle.moveIndex = 0;
                                particle.nextIndex = 1
                            }
                        }
                        var currentPoint = path[particle.moveIndex];
                        var nextPoint = path[particle.nextIndex];
                        particle.copy(currentPoint);
                        particle.lerpSelf(nextPoint, particle.lerpN)
                    }
                    this.geometry.verticesNeedUpdate = true
                };
                splineOutline.affectedCountries = affectedCountries;
                return splineOutline;
            }
            function attachMarkerToCountry(countryName, importance) {
                countryName = countryName.toUpperCase();
                var country = countryData[countryName];
                if (country === undefined) return;
                var container = document.getElementById('visualization');
                var template = document.getElementById('marker_template');
                var marker = template.cloneNode(true);
                country.marker = marker;
                container.appendChild(marker);

                marker.countryName = countryName;
                marker.importance = importance;
                marker.selected = false;
                marker.hover = false;
                if (countryName === selectedCountry.countryName.toUpperCase()) {
                    marker.selected = true;
                }
                marker.selected = true;
                marker.setPosition = function(x, y, z) {
                    this.style.left = x + 'px';
                    this.style.top = y + 'px';
                    this.style.zIndex = z
                }
                marker.setVisible = function(vis) {
                    if (!vis) this.style.display = 'none';
                    else {
                        this.style.display = 'inline'
                    }
                }
                var countryLayer = marker.querySelector('#countryText');
                marker.countryLayer = countryLayer;
                var detailLayer = marker.querySelector('#detailText');
                marker.detailLayer = detailLayer;
                marker.jquery = $(marker);
                marker.setSize = function(s) {
                    var detailSize = Math.floor(2 + s * 0.5);
                    this.detailLayer.style.fontSize = 10 + 'pt';
                    var totalHeight = detailSize * 2;
                    this.style.fontSize = 10 + 'pt';
                    if (detailSize <= 8) {
                        this.countryLayer.style.marginTop = "0px"
                    } else {
                        this.countryLayer.style.marginTop = "-1px"
                    }
                }
                marker.update = function() {
                    var matrix = rotating.matrixWorld;
                    var abspos = matrix.multiplyVector3(country.center.clone());
                    var screenPos = screenXY(abspos);
                    var s = 0.3 + camera.scale.z * 1;
                    var importanceScale = this.importance / 5000000;
                    importanceScale = constrain(importanceScale, 0, 18);
                    s += importanceScale;
                    if (this.tiny) s *= 0.75;
                    if (this.selected) s = 30;
                    if (this.hover) s = 15;
                    this.setSize(s);
                    this.setVisible((abspos.z > 60) && s > 3);
                    var zIndex = Math.floor(1000 - abspos.z + s);
                    if (this.selected || this.hover) zIndex = 10000;
                    this.setPosition(screenPos.x, screenPos.y, zIndex);
                    function screenXY(vec3) {
                        var projector = new THREE.Projector();
                        var vector = projector.projectVector(vec3.clone(), camera);
                        var result = new Object();
                        var windowWidth = cwidth;
                        result.x = Math.round(vector.x * (windowWidth / 2)) + windowWidth / 2;
                        result.y = Math.round((0 - vector.y) * (cheight / 2)) + cheight / 2;
                        return result;
                    }
                }
                var nameLayer = marker.querySelector('#countryText');
                var tiny = (importance < 20000000) && (!marker.selected);
                marker.tiny = tiny;
                nameLayer.innerHTML = countryName.replace(' ', '&nbsp;');
                var importExportText = "这里显示各种内容";
                if (country.exportedAmount > 0 && country.importedAmount > 0) {
                    importExportText += "攻击类型:&nbsp;" + numberWithCommas(country.importedAmount) + "<br />设备类型:&nbsp;" + numberWithCommas(country.exportedAmount)
                } else if (country.exportedAmount > 0 && country.importedAmount == 0) {
                    importExportText += "设备类型:&nbsp;" + numberWithCommas(country.exportedAmount) + "<br />&nbsp;"
                } else if (country.exportedAmount == 0 && country.importedAmount > 0) {
                    importExportText += "攻击类型:&nbsp;" + numberWithCommas(country.importedAmount) + "<br />&nbsp;"
                }
                function numberWithCommas(x) {
                    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
                }
                marker.importExportText = importExportText;
                var markerOver = function(e) {
                    this.detailLayer.innerHTML = importExportText;
                    this.hover = true
                }
                var markerOut = function(e) {
                    this.detailLayer.innerHTML = "";
                    this.hover = false;
                }
                if (!tiny) {
                    detailLayer.innerHTML = importExportText;
                } else {
                    marker.addEventListener('mouseover', markerOver, false);
                    marker.addEventListener('mouseout', markerOut, false)
                }
                var markerSelect = function(e) {
                    alert("这里显示具体信息");
                    var selection = selectionData;
                    //EarthModel.selectVisualization(timeBins, [selection.selectedCountry]);
                    //EarthModel.selectVisualization(timeBins,  [this.countryName], selection.getExportCategories(), selection.getImportCategories())
                };
                marker.addEventListener('click', markerSelect, true);
                markers.push(marker);
            }
            function removeMarkerFromCountry(countryName) {
                countryName = countryName.toUpperCase();
                var country = countryData[countryName];
                if (country === undefined) return;
                if (country.marker === undefined) return;
                var index = markers.indexOf(country.marker);
                if (index >= 0) markers.splice(index, 1);
                var container = document.getElementById('visualization');
                container.removeChild(country.marker);
                country.marker = undefined;
            }
        },
        highlightCountry: function(countries) { //高亮显示模块
            var ctx = lookupCanvas.getContext('2d');
            ctx.clearRect(0, 0, 256, 1);
            var pickMask = countries.length == 0 ? 0 : 1;
            var oceanFill = 10 * pickMask;
            ctx.fillStyle = 'rgb(' + oceanFill + ',' + oceanFill + ',' + oceanFill + ')';
            ctx.fillRect(0, 0, 1, 1);
            var nameTag;
            for (var i in countryLookup) {
                if (countryLookup[i] == countries) {
                    nameTag = i;
                };
            }
            var colorIndex = countryColorMap[nameTag];
            var fillCSS = '#eeeeee';
            ctx.fillStyle = fillCSS;
            ctx.fillRect(colorIndex, 0, 1, 1);
            lookupTexture.needsUpdate = true;
        },
    }
    EarthModel.run();
    function constrain(v, min, max) {
        if (v < min) {
            v = min
        } else if (v > max) {
            v = max
        }
        return v
    }
}
$(document).ready(function() {
    earth()
});